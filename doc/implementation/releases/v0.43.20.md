# v0.43.20 — UX/Perf：Hover 预览可滚动（全文/长图）+ 预览高度按屏幕上限自适应

**日期**：2025-12-15

## 📌 一页纸总结（What / Why / Result）

- **What**：
  - **文本 hover 预览支持“全文滚动”**：不再只展示首尾截断；预览框高度按内容自适应（上限为当前屏幕可视高度的 70%），鼠标移入预览框后可直接滚动查看全部内容。
  - **文本预览改用 AppKit `NSTextView + NSScrollView`**：提升大文本渲染与滚动的稳定性，避免 SwiftUI `Text` 在极端长文本下首帧/布局开销偏大。
  - **图片 hover 预览固定宽度 500pt**：高度按等比缩放后的实际高度自适应（上限为当前屏幕可视高度的 70%）；长图超出上限后在预览框内纵向滚动查看全图。
  - **图片预览 downsample 按目标宽度优化**：优先保证 500pt 宽度下的清晰度；对极端长图增加最大长边像素上限（避免一次性解码导致内存峰值/卡顿）。
- **Why**：让 hover 预览真正可用于“阅读/浏览”（全文、长截图），同时保持列表滚动与 hover 首帧的流畅度。
- **Result**：文本与图片 hover 预览在不牺牲性能的前提下更可用：尺寸更贴合内容，长内容可在预览框内滚动，不卡顿。

## 🏗️ 实现路线

1. 文本预览：将预览内容改为全文输出；预览 UI 替换为 `NSTextView`（只读可选中）+ `NSScrollView`，并将预览高度与滚动策略收口在单一组件内。
2. 图片预览：统一预览框宽度为 500pt；按等比计算“自然高度”，超过屏幕上限则启用 `ScrollView`。
3. 图片解码：在 hover 预取链路中读取图片像素尺寸，按“目标宽度”计算需要的 thumbnail max pixel size，并对极端长边做上限保护。
4. 增加屏幕上限工具：根据鼠标所在屏幕的 `visibleFrame` 计算预览最大高度（70%）。

## 📂 核心改动

- `Scopy/Views/History/HistoryItemView.swift`：文本 hover 预览改为全文；图片 hover 预览 downsample 按目标宽度计算，并增加极端长边上限。
- `Scopy/Views/History/HistoryItemTextPreviewView.swift`：用 `NSTextView + NSScrollView` 实现高性能全文预览（自适应高度 + 超出滚动）。
- `Scopy/Views/History/HistoryItemImagePreviewView.swift`：预览宽度固定 500pt；高度按图片等比自适应；长图在预览框内滚动。
- `Scopy/Views/History/HoverPreviewScreenMetrics.swift`：根据当前屏幕可视高度计算 popover 最大高度（70%）。

## 🎯 关键指标

**测试环境**：Apple M3 / macOS 15.7.2（24G325）/ arm64 / 2025-12-15

- Debug build：`make build` ✅
- 单元测试：`make test-unit` **147 passed** (1 skipped)
- Strict Concurrency：`make test-strict` **147 passed** (1 skipped)
- 性能测试：`make test-perf` **23 passed** (6 skipped)

## 📊 当前状态（快速检查）

- ✅ Hover 文本预览：全文 + 自适应高度 + 预览框内滚动
- ✅ Hover 图片预览：500pt 固定宽度 + 屏幕 70% 高度上限 + 长图滚动
- ✅ `make test-unit`
- ✅ `make test-strict`
- ✅ `make test-perf`

## 🔮 遗留与后续

- 如需要进一步优化“极端超长图”（例如高度数万像素）的清晰度与内存峰值，可考虑引入分片/瓦片渲染（tile-based）或按视口增量解码策略。
