v0 极简开发清单（围绕 4 个核心目标）

---

## 1. macOS 原生漂亮 UI + 前后端彻底解耦

### 1.1 架构要求

* [ ] 前后端分离：

  * 后端： **ClipboardService / StorageService** ，只提供结构化数据和命令接口，不关心 UI。
  * 前端： **UI Shell** （菜单栏 + 弹出窗 + 设置窗），只通过协议/接口访问后端。（最好能从maccy抽出其UI)
* [ ] 接口形式（建议）：

  * `func fetchRecent(limit:Int, offset:Int) -> [ClipboardItemDTO]`
  * `func search(query:SearchRequest) -> SearchResultPage`
  * `func pin(itemID) / unpin(itemID)`
  * `func updateSettings(SettingsDTO)`
  * `func observeEvents(handler: (ClipboardEvent) -> Void)`  // 新增条目、删除、设置变更等

### 1.2 UI 设计基线（参考 Maccy 风格）

* [ ] 菜单栏常驻图标 + 快捷键弹出主窗口（如 ⇧⌘C）。
* [ ] 弹出窗口：
  * 顶部：搜索框 + 简洁过滤控件（如 app 过滤按钮）。
  * 中部：虚拟列表（类 Maccy），每行显示：
    * 左：内容缩略（文本首行 / 缩略图 / 文件图标）。
    * 右：来源 app 图标 / 时间 / Pin 标记。
* [ ] 视觉风格：
  * 跟随浅/深色模式；
  * 使用 SF Symbols & 系统字体；
  * 动画简洁（淡入/缩放），不引入复杂自定义动画。

### 1.3 解耦验收标准

* [ ] 后端可以用一个简单 **CLI / 单元测试** 驱动，不依赖任何 UI 代码。
* [ ] UI 可以在「后端 mock」模式下运行（前端只依赖协议，不 import 具体实现）。
* [ ] 将来替换 UI 框架（例如从 SwiftUI 切到 AppKit 组件），不需要改动存储/搜索逻辑。

---

## 2. 无限历史 + 分级存储 + 懒加载浏览

### 2.1 历史与分级存储设计

* [ ] 支持「逻辑上无限」历史（架构不依赖硬上限），通过策略清理控制体积：
  * 按条数：如最多 N 条；（默认1w条)
  * 按时间：如保留最近 X 天；（默认无限时间)
  * 按空间：如总大小不超过 Y GB。（默认是小内容200MB上限，大内容另外限制比如800MB)
* [ ] 分级存储策略：
  * 小内容（文本等，< X KB）：SQLite 内联存储。
  * 大内容（图片 / 大文本 / 文件，≥ X KB）：外部文件 + DB 中只存 path/元数据。
  * 缩略图单独缓存目录 + LRU 管理。

### 2.2 完整历史查看 + 懒加载

* [ ] 完整历史视图：
  * UI 中可以滚动到「很久很久以前」的条目（1 万+ 级）。
  * 后端提供分页接口：`fetchRecent(limit, offset)`。
* [ ] 懒加载行为：
  * 首屏只加载最近 50–100 条。
  * 滚动时按页加载，例如每页 100 条。
  * 所有 DB 读取在后台队列执行，返回结果再更新 UI。

### 2.3 空间管理与设置

* [ ] 设置项（最少支持）：
  * 最大条数（如 1k / 5k / 10k / 自定义）。
  * 最大空间（如 1GB / 5GB / 自定义）。（支持)
  * 是否保存图片 / 文件内容。
* [ ] 后端定期执行：
  * 过期清理（按条数/时间/空间）。
  * SQLite housekeeping（auto_vacuum + incremental_vacuum）。

---

## 3. 数据结构 / 索引，为去重 & 各类搜索打好地基

### 3.1 核心数据结构（逻辑模型）

* [ ] `ClipboardItem` 核心字段：
  * `id`
  * `type`（text / rtf / html / image / file / other）
  * `contentHash`（用于去重）
  * `plainText`（可索引的文本内容 / 摘要）
  * `appBundleID`
  * `createdAt`, `lastUsedAt`
  * `isPinned`
  * `sizeBytes`
  * `storageRef`（内联 / 外部文件路径）
* [ ] 索引设计（DB 层）：
  * 按时间：`createdAt DESC`，`lastUsedAt DESC`
  * 按 Pin：`isPinned DESC, lastUsedAt DESC`
  * 按 hash：`contentHash`（去重）
  * FTS 索引：`plainText` 字段

### 3.2 去重策略

* [ ] 去重逻辑：
  * 计算 `contentHash`（针对主文本或主图片数据）。
  * 写入前先查最近 N 条或按 hash 索引查重复。
  * 重复则只更新 `lastUsedAt` & 使用计数，不新建条目。
* [ ] 精度要求：
  * 文本：基于标准化后的字符串（去首尾空白、统一换行）。
  * 图片：可以先用尺寸 + 快速 hash（如感知 hash）再决定是否算重复。

### 3.3 搜索模式支持（接口层）

* [ ] 前端/后端共识的搜索请求结构：

```ts
type SearchMode = "exact" | "fuzzy" | "regex";

interface SearchRequest {
  query: string;
  mode: SearchMode;
  appFilter?: string;   // 按来源 app 过滤
  typeFilter?: string;  // 按内容类型过滤
  limit: number;
  offset: number;
}
```

* [ ] 必须支持：
  * 精确匹配（exact）：直接 FTS OR LIKE。
  * 模糊搜索（fuzzy）：如 FTS + 模糊匹配规则（前缀、大小写不敏感）。
  * 正则搜索（regex）：可限制仅对结果子集或小规模历史执行，避免 O(n)。

---

## 4. 超高性能搜索 + 渐进式结果返回

### 4.1 性能目标（可量化）

* [ ] 常规规模（≤ 5k 条）：
  * 搜索请求 → 首屏结果返回：P95 ≤ 50ms。
* [ ] 大规模（10k–100k 条）：
  * 搜索请求 → 返回前 50 条结果：P95 ≤ 100–150ms。
* [ ] 输入过程：
  * 用户连续输入时，UI 不阻塞，搜索有 150–200ms 防抖。

### 4.2 搜索实现策略

* [ ] 基础策略：
  * 使用 SQLite FTS5 作为主文本索引。
  * 搜索调用全部在后台队列执行，UI 只订阅结果。
* [ ] 渐进式加载：
  * 接口返回分页结果：`SearchResultPage { items, total, hasMore }`
  * 前端：
    * 首先展示前 50 条；
    * 滚动时自动加载后续分页；
    * 允许用户「加载更多」或自动触底加载。
* [ ] 短词/长词优化：
  * 短词（1–2 字符）：可以先在内存缓存的最近 N 条上做快速过滤。
  * 长词：直接走 FTS 查询。

### 4.3 用户体验要求

* [ ] 搜索框输入时：
  * 立即能看到“正在搜索...”之类轻量状态（非阻塞）。
  * 结果逐步刷新，而不是“长时间空白后一次性显示全部”。
* [ ] 搜索结果排序：
  * 默认：匹配度 + 最近使用时间组合排序。
  * 相同文本的不同时间版本可折叠显示（可后续迭代）。

---

## 一句话总结版本（给团队看的目标）

* UI： **原生、好看、Maccy 级体验** ，但用协议把 UI 和后端完全隔离。
* 历史： **逻辑上无限** ，用分级存储 + 自动清理稳住磁盘和内存。
* 数据：一个统一的 `ClipboardItem` 模型，把去重、筛选、三种搜索（精确/模糊/正则）全部设计进来。
* 搜索：对用户来说就是——**不管历史有多大，搜索都是“打字就出结果”，首屏在几十毫秒内出来，结果还能渐进加载。**
