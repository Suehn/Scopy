# v0.43.1 - Fix/Quality：热键应用一致性 + 去重事件语义 + 测试稳定性

**日期**: 2025-12-14

---

## 一页纸总结

### What

- **热键应用一致性**：`AppState` 在 `.settingsChanged` 时始终触发 `applyHotKeyHandler`；`AppDelegate.applyHotKey` 做幂等（相同配置不重复 unregister/register），避免冗余与竞态漏应用。
- **去重事件语义修复**：`StorageService` 提供内部 `upsertItemWithOutcome`（insert vs update），`ClipboardService` 仅在真正插入时发 `.newItem`，去重命中时发 `.itemUpdated`，避免 UI `totalCount` 被错误累加。
- **设置保存 UX**：设置保存失败时不再自动关闭窗口，显示错误提示；保存成功后由 `.settingsChanged` 统一驱动 UI/热键同步。
- **资源释放与测试稳定性**：`StorageService.close/performWALCheckpoint/getExternalStorageSize` 全面异步化（避免主线程阻塞）；`PerformanceTests` 清理逻辑改为 async（消除 `@MainActor` + semaphore 的潜在死锁）；Strict Concurrency 下修复泛型 Sendable 报错。

### Why

- `.settingsChanged` 的“只在变更时才 applyHotKey”做法在并发/时序下可能误判导致热键不生效；更安全的策略是 **总是触发**，在 `AppDelegate` 做幂等。
- 去重 upsert 语义若仍发 `.newItem`，会导致分页统计（`totalCount`）与过滤列表更新不正确，且难以在 UI 层可靠修正。
- 测试侧对 `@MainActor` 服务使用 semaphore wait 会阻塞主 actor，造成偶现卡住；改为纯 async teardown 更安全。

### Result

- 事件语义、热键应用与设置保存路径更一致，UI 状态更新更可预测。
- 回归通过：
  - `make test-unit`：53 passed, 1 skipped
  - `make test-perf`：22 passed, 6 skipped
  - `make test-tsan`：132 passed, 1 skipped
  - `make test-strict`：166 passed, 7 skipped

---

## 实现路线

1. `AppDelegate.applyHotKey` 增加“最后一次应用配置”缓存，支持幂等与显式 unregister 后的重注册。
2. `AppState` 在 `.settingsChanged` 统一：reload settings → applySettings → applyHotKey → reload list。
3. `StorageService` 增加内部 upsert outcome，`ClipboardService` 对应发出 `.newItem` / `.itemUpdated`。
4. `HistoryViewModel` 基于新事件语义修正 `totalCount` 更新，并在 `.itemDeleted` 下避免在过滤/搜索态误减计数。
5. 更新测试：异步 close/checkpoint/size API 调用点；修复 perf teardown 与 Strict Concurrency 报错。

---

## 修改文件列表（核心）

- `Scopy/AppDelegate.swift`
- `Scopy/Observables/AppState.swift`
- `Scopy/Observables/HistoryViewModel.swift`
- `Scopy/Observables/SettingsViewModel.swift`
- `Scopy/Views/SettingsView.swift`
- `Scopy/Application/ClipboardService.swift`
- `Scopy/Services/StorageService.swift`
- `ScopyTests/PerformanceTests.swift`
- `ScopyTests/ResourceCleanupTests.swift`
- `ScopyTests/*`（async close API 对齐）

---

## 关键指标

### 测试

- 单元测试：`make test-unit` **53 passed** (1 skipped)
- 性能测试：`make test-perf` **22 passed** (6 skipped；heavy 需 `RUN_HEAVY_PERF_TESTS=1`)
- Thread Sanitizer：`make test-tsan` **132 passed** (1 skipped)
- Strict Concurrency：`make test-strict` **166 passed** (7 skipped)

### 性能（Debug / `make test-perf` 单次运行）

- 环境：Apple M3 / macOS 15.7.2（24G325）/ arm64 / 2025-12-14
- 电源：Low Power Mode = enabled（`pmset -g` 显示 `lowpowermode 1`）
- 关键结果：
  - Fuzzy 5k items P95 ≈ 8.49ms
  - Fuzzy 10k items P95 ≈ 79.41ms（Samples: 50；Low Power Mode 下测试阈值放宽至 300ms）
  - Disk 25k fuzzy P95 ≈ 102.93ms（Samples: 50）
  - Bulk insert 1000 items ≈ 140.62ms（≈7,112 items/s）
  - Fetch recent (50 items) avg ≈ 0.11ms
  - Regex 20k items P95 ≈ 5.25ms
  - Mixed content disk search（single run）≈ 7.56ms

---

## 当前状态（快速检查）

- ✅ `make test-unit`
- ✅ `make test-perf`
- ✅ `make test-tsan`
- ✅ `make test-strict`

---

## 遗留与后续

- Low Power Mode 下的性能抖动更明显：可考虑在 UI 滚动/渲染链路进一步降低主线程工作（例如更严格的缩略图生成节流、预取策略与渲染分批）。
- 若需要在低功耗场景继续提升搜索尾部，可评估在 10k 量级引入更轻的候选集预筛策略（同时保持召回一致性）。
