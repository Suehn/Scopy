# v0.24 - 超深度全仓库代码审查 & 悬停预览稳定性修复

**日期**: 2025-12-12  
**范围**: 全仓库（`Scopy/`、`ScopyTests/`、`doc/`）  
**重点**: 性能、稳定性、并发安全、内存/磁盘、与 `doc/dev-doc/v0.md` 规格一致性  

---

## 📌 一页纸总结（Executive Summary）

### 本次代码变更
- **修复图片缩略图悬停预览闪烁**：List 行 `.popover` 触发 hover false 导致弹窗瞬闪/立刻消失的问题。
  - 方案：增加 **120ms 退出防抖** + **popover 内 hover 保活**（`Scopy/Views/HistoryListView.swift:149-155, 386-468`）。
  - 现象验证：`make test-unit` 通过（51 tests / 0 failures），手动 hover 预览稳定。

### 总体结论
工程整体已达到 v0.md 的“功能闭环 + 性能基础达标”水平；但 **仍有 3 个高风险点（P0/P1）属于原理层面隐患**，可能解释“修过多次仍偶发”的问题：

**P0（必须尽快修）**
1. **SearchService 缓存真实数据竞争**  
   - `SearchService` 标注 `@MainActor`，但缓存读写实际发生在自建后台 `queue`；  
   - 后台无锁读取 `recentItemsCache`（`SearchService.swift:293-303`）与主线程锁内写入 `invalidateCache()`（`SearchService.swift:397-401`）可能并发 → 崩溃/随机结果。  
   - 这是“修复报告说 ok 但仍可能复发”的典型源头。

**P1（应做结构性优化）**
2. **缩略图与原图获取仍有主线程重活**  
   - `RealClipboardService.handleNewContent` 新复制图片 **同步生成缩略图**（`RealClipboardService.swift:322-329`），  
   - `scheduleThumbnailGeneration` 虽 detached，但 **取原图 + 生成缩略图仍 MainActor.run**（`RealClipboardService.swift:396-404`）。  
   - 大量图片/首次滚动仍可能 UI 卡顿。
3. **外部存储写盘在 MainActor**  
   - `StorageService.upsertItem` 在 MainActor 内直接 `storeExternally()` 写文件（`StorageService.swift:311-332, 1194-1209`）。  
   - 复制大图/大文件时可能阻塞 UI。

**P2/P3（不致命但影响质量/性能的点）**
- ClipboardMonitor 任务队列 “taskIDMap 为唯一数据源” 仍有细小偏差（取消最旧任务时未同步移除 map，`ClipboardMonitor.swift:279-353`）。  
- `IconCache.getCached` 永远返回 nil 是死代码（`IconCache.swift:40-72`）。  
- 少量 `try?` 仍存在（HotKey 日志轮转、regex 构造等），属可接受范围但应明确意图。

---

## 🔍 审查方法与原则

1. **直接读代码**：不依赖 CHANGELOG/版本文档的结论，按“能否复现/原理是否闭合”来评估。
2. **自顶向下对齐规格**：以 v0.md 的 4 个核心目标为 checklist，逐条对照实现。
3. **性能审查聚焦三类真实成本**  
   - **主线程阻塞**：任何磁盘 I/O、SQLite step、图片解码/缩放。  
   - **O(n) 级 UI 重绘/追踪**：SwiftUI @Observable 追踪、List 回收、ForEach 数据源。  
   - **缓存/内存增长路径**：是否有上界、LRU 是否正确。
4. **并发/稳定性审查聚焦“隔离一致性”**  
   - Actor/锁/队列是否在同一套语义下使用；  
   - 有无 “标 MainActor 但后台访问状态” 的混用。

---

## ✅ 与 v0.md 规格逐条对照

### 目标 1：macOS 原生漂亮 UI + 前后端彻底解耦

**规格要点**
- UI 只依赖协议，不 import 具体后端；
- 后端可用 CLI/单测驱动；
- Mock/Real 可互换。

**现状评估**
- **已实现**：
  - `ClipboardServiceProtocol` 定义后端能力（`Scopy/Protocols/ClipboardServiceProtocol.swift:288-360`），UI 只通过协议访问；
  - `AppState` 通过环境注入 service（Mock/Real 工厂）实现解耦（`AppState.swift:93-167`）；
  - Debug/Release 通过 `USE_MOCK_SERVICE` 可切换（`AppState.swift:136-153`）。
- **偏离/可改进**：
  - 协议被标 `@MainActor`（`ClipboardServiceProtocol.swift:288`），导致 Real/Mock 服务很难完全后台化；  
    v0.md 期望“DB 读取后台执行、UI 仅订阅结果”。  
  - 当前 Real 服务内部仍有主线程磁盘/图片重活（见 P1/P2）。

**结论**：功能/结构解耦到位，但“MainActor 化后端”在性能上与规格精神略有冲突。

---

### 目标 2：无限历史 + 分级存储 + 懒加载浏览

**规格要点**
- 小内容内联 SQLite，大内容外部文件；
- UI 分页 fetchRecent；
- 自动清理（按条数/时间/空间）；
- DB housekeeping（WAL + vacuum）。

**现状评估**
- **已实现**：
  - 分级存储阈值 100KB（`StorageService.externalStorageThreshold`）；外部文件 + thumbnails 目录分离（`StorageService.swift:56-110`）。
  - UI 首屏 50 条、触底分页（`AppState.load`、`AppState.loadMore`）。
  - 清理策略按 count/age/db size/external size + incremental_vacuum + orphan 清理（`StorageService.performCleanup:730-769`）。
  - WAL 模式与 checkpoint（`StorageService.open:140-176`, `performWALCheckpoint:188-193`）。
- **偏离/可改进**：
  - **外部写盘在 MainActor**（P2），与“后台 I/O”目标冲突；
  - 清理过程仍在 MainActor 调用（RealClipboardService 里 `performCleanup`），虽然删除外部文件后台化，但 SQL 删除/事务仍在主线程（可能卡顿）。

**结论**：架构上满足 v0.md；但执行隔离需改进，否则“大内容复制/清理”仍会抖 UI。

---

### 目标 3：数据结构/索引，为去重 & 搜索打地基

**规格要点**
- ClipboardItem 必要字段与索引；
- 去重基于 contentHash（文本标准化、图片 hash）。

**现状评估**
- **已实现字段**：id/type/contentHash/plainText/appBundleID/createdAt/lastUsedAt/isPinned/sizeBytes/storageRef/rawData（`StorageService.StoredItem`）。
- **去重**：
  - 文本 normalize（trim + CRLF 统一）再 hash（`ClipboardMonitor.normalizeText:548-559`）。
  - 所有类型 SHA256 去重（`ClipboardMonitor.computeHashStatic:584-593`），图片统一走后台 SHA256（`ClipboardMonitor.checkClipboard:248-273`）。
  - DB 以 content_hash 索引查重（`findByHash`）并更新 useCount（`StorageService.upsertItem:311-321`）。
- **索引与 FTS**：`createIndexes/setupFTS` 结构齐全；FTS 触发器 on insert/update/delete 已实现（`StorageService.swift:238-306`）。
- **可改进**：
  - `upsertItem` 查重是同步 SQL（MainActor），高频复制 + 大库下可能成为热点。

**结论**：数据模型与索引符合 v0.md；去重精度与安全性较高。

---

### 目标 4：超高性能搜索 + 渐进式结果返回

**规格要点**
- ≤5k P95 ≤50ms；大库首屏 ≤150ms；
- 150–200ms 防抖；
- FTS5 为主，短词走内存缓存；
- 分页/渐进结果。

**现状评估**
- **已实现**：
  - 搜索防抖 150ms（`AppState.search:460-525`）；
  - Exact 模式：FTS5 两步查询 + LIMIT+1（`SearchService.searchWithFTS:178-287`）；
  - 短词 ≤2 字：内存 cache（`SearchService.searchExact:106-110`），cacheSize=2000、TTL=30s；
  - UI 分页显示 `hasMore/offset`。
- **偏离/风险**：
  1. **数据竞争（P0）**：cache 读写跨线程且锁语义不一致（见 Executive Summary）。
  2. **Fuzzy/FuzzyPlus 只在缓存上匹配**（`searchFuzzy/searchFuzzyPlus` → `searchInCache`），意味着只覆盖最近 2000 条；  
     v0.md 目标是“无限历史上搜索都正确”，此处是**功能/规格偏离**。  
     目前“默认 fuzzyPlus”会让用户认为搜索全量，但实际上非全量。
  3. Regex 限制在缓存上执行与规格一致，但应在 UI 提示“仅搜索最近 N 条”。

**结论**：Exact 性能路径优秀；Fuzzy 系列需要在“正确性 vs 性能”间重新对齐规格。

---

## 🚀 前端（SwiftUI/UI Shell）性能深度分析

### 1) 视图结构与重绘

- **List 虚拟化替代 LazyVStack**：正确方向，避免 10k 级别内存飙升（`HistoryListView`）。
- **@Observable 追踪降噪**：  
  - pinned/unpinned 访问缓存到局部变量，减少追踪（`HistoryListView.swift:33-54`）。  
  - `ClipboardItemDTO` 预计算 metadata/title，避免每次 body O(n)（`ClipboardServiceProtocol.swift:32-150`）。  
  - `relativeTime` static 缓存 now，每 30s 更新，避免频繁 Date 分配（`HistoryListView.swift:633-655`）。

**剩余热点**
- `HistoryItemView.appIcon` 本地缓存 LRU 更新为 O(n)（访问顺序数组），但上限 50，成本可忽略。  
  如果未来上限增大，建议改为 `OrderedSet` 或 dict+linked list O(1)。

### 2) 图片缩略图与预览链路

**路径分解**
1. 新复制图片 → `ClipboardMonitor` 提取 PNG → SHA256 后台 → yield content。  
2. `RealClipboardService.handleNewContent` 存储 → 若 showThumbnails 立刻生成缩略图（同步）。  
3. List 渲染：若无缩略图，`scheduleThumbnailGeneration` detached 生成。  
4. Hover 预览：`HistoryItemView.startPreviewTask` 获取原图 data，延迟后 popover 展示。

**已知问题与本次修复**
- **闪烁根因**：macOS SwiftUI `.popover` 在出现/消失时会重建 tracking area，导致 anchor 行瞬间收到 `hovering=false`。原逻辑在 hover false 时立刻 `showPreview=false`（`HistoryItemView`），于是 popover “刚开就被关”。  
- **修复策略（v0.24 已落地）**：
  1. **退出防抖 120ms**：hover false 不立刻清理，而是延迟确认（`HistoryListView.swift:414-426`）。  
  2. **popover hover 保活**：鼠标进入 popover 时取消退出任务；离开 popover 且行未悬停时再延迟关闭（`HistoryListView.swift:429-468`）。  

**性能风险（仍未完全解决）**
- 新复制图片同步生成缩略图（MainActor，见 P1）。  
  建议：  
  - 在后台生成缩略图并写盘，主线程只更新 DTO 的 thumbnailPath 或触发 UI refresh。  
  - 或在复制路径只记录任务，滚动/显示时懒生成。
- Hover 预览获取原图目前仍走 `service.getImageData`（MainActor）→ `StorageService.getOriginalImageData` → SQLite 查询/磁盘读取。  
  虽然只在 hover 时发生，但对大图仍有潜在 UI 抖动风险，建议把原图加载放到后台并在完成时回到主线程更新 state。

### 3) 搜索输入与 UI 响应

- `HeaderView.TextField.onChange` 每字符触发 `appState.search()`（`HeaderView.swift:18-26`），依赖 `AppState.search` 内部防抖。  
  该结构符合 v0.md，且能避免 UI 层自己做 debounce 的复杂度。
- **潜在热点**：  
  - 当 searchQuery 很长且 mode=fuzzyPlus 时，后台 cache-filter 的 O(n×m) 会变重；  
  - 但对 UI 影响主要取决于 SearchService 的后台执行是否正确隔离（目前存在 P0 数据竞争）。

### 4) App/Type 过滤菜单

- AppFilterButton/TypeFilterButton 使用静态缓存 + LRU 上限 50，且 NSWorkspace 调用在锁外（`HeaderView.swift` 相关组件）。  
  这是 UI 性能与稳定性的合理权衡。  
- 可选优化：统一复用 `IconCacheSync`，避免重复维护两套 icon/name 缓存（目前两套上界都小，影响不大）。

---

## 🔎 搜索性能与正确性深度分析

### 1) Exact 模式（FTS5 两步查询）

**实现**
- Step1: `clipboard_fts MATCH ?` 获取 rowid 列表（bm25 排序，LIMIT+1 判断 hasMore）。  
- Step2: 主表 `rowid IN (...)` 批量取数据，并保持 FTS 顺序 + pinned 置顶。  
  代码位于 `SearchService.searchWithFTS`。

**性能评价**
- 两步查询避免 JOIN 代价；LIMIT+1 避免 COUNT → 对 5k–50k 数据规模是最优解之一。  
- P95 目标（≤50ms/≤150ms）在当前实现中“理论可达”，且测试也覆盖了 timing（`SearchServiceTests`）。

**可选改进**
- **Pinned 置顶 + FTS 顺序** 的 CASE 排序会生成较长 SQL（rowid 多时），不过 rowids 上限 request.limit+1（50-101），成本可控。  
- 若未来 limit 变大，可考虑临时表/CTE 方式。

### 2) Fuzzy / FuzzyPlus 模式

**实现**
- 统一走 `searchInCache`，即 **只对 recentItemsCache（<=2000）做模糊匹配**。  
  - fuzzy：字符顺序匹配（`SearchService.fuzzyMatch:406-419`）。  
  - fuzzyPlus：按空格分词，每词 fuzzy（`SearchService.fuzzyPlusMatch:423-439`）。

**问题**
- **规格偏离**：v0.md 期待“无限历史全量搜索正确”，当前 fuzzy 只覆盖最近 2000 条。  
  - 用户默认模式是 fuzzyPlus（`SettingsDTO.default.defaultSearchMode`），因此默认行为即非全量。  
  - 这是功能正确性风险，而非单纯性能问题。

**建议（两条可选路径）**
1. **正确性优先**：对长 fuzzy 查询（>=3 字/词）先用 FTS 扩大候选，再在候选集上 fuzzy 排序/过滤。  
   - 可复用 `searchWithFTS(useFuzzyRanking: true)`，只改 query 构造与后过滤逻辑。  
2. **性能优先但需 UI 明示**：保留“仅最近 N 条 fuzzy”，但 UI 要展示范围提示，并允许用户切换“全量 fuzzy”。  

### 3) Regex 模式

- 限制在缓存上执行与 v0.md 设计一致（避免 O(history)），且 regex 构造失败会 throw invalidQuery。  
- 可选：在 UI 显示“仅搜索最近 N 条”的提示，保持一致性。

### 4) 并发与取消

- `runOnQueueWithTimeout` 用 `TaskGroup` race 超时 → 正确避免任务泄漏。  
- **但缓存并发（P0）需要修**：  
  - `@MainActor SearchService` + 后台 queue 的混用是根因；  
  - 建议单一策略：要么彻底后台化 SearchService（去掉 MainActor，并保证所有状态在 queue 内）；要么彻底 MainActor 化（移除 queue）。

---

## 💾 存储、内存、磁盘性能深度分析

### 1) SQLite 配置与 schema

- WAL + NORMAL synchronous + 64MB cache + temp_store MEMORY（`StorageService.open:150-158`）。  
  对读多写少场景非常合理。
- FTS5 触发器维护 fts 表，确保一致性。  

### 2) 分级存储与大内容处理

- >100KB 内容写入外部文件，DB 只存 path（`upsertItem:329-334`）。  
  这个阈值和策略符合 v0.md。

**主要性能风险**
- **写外部文件在 MainActor**（P1）。  
  复制大图时 `writeAtomically` 会做真实磁盘写入和 rename，耗时可能几十 ms–数百 ms。  
  在剪贴板高频事件里，这是 UI 卡顿源头之一。

**建议**
- 让 `storeExternally` 运行在后台队列/actor；完成后回主线程写入 DB 与 yield event。  
- 或者把 StorageService 本身迁出 MainActor，并在内部用串行队列保护 db（更接近 v0.md 精神）。

### 3) 清理策略与磁盘占用

- count/age/size/external size 的清理都用批量 SQL + 事务（`cleanupByCount/BySize`）→ 性能极佳。  
- 外部文件删除后台并行执行，且不阻塞 wait（`deleteFilesInParallel`）。  
- orphan 清理已后台化且会 invalidate size cache（`cleanupOrphanedFiles`）。

**潜在风险**
- `performCleanup` 仍在 MainActor 同步调用：  
  - SQL 扫描/删除在大库下仍可能卡顿；  
  - 建议把 cleanup 触发到后台队列。

### 4) 内存增长路径

**已设上界的缓存**
- Search short cache：2000 items、TTL 30s、去除 rawData（~轻量，`SearchService.refreshCacheIfNeeded`）。  
- Thumbnail cache：1000 images（~20MB 上限，`HistoryItemView` 静态 LRU）。  
- Icon caches：上界 50/100 条（`HistoryItemView`, `IconCacheSync`, `AppFilterButton`）。  

**可选改进**
- 统一缓存实现，避免多处 LRU 手写；但目前每处上界小，不是优先级。

---

## 🧵 稳定性与并发安全审查

### 1) 锁/actor 使用一致性

**优点**
- 全仓统一 `NSLock.withLock` 扩展，避免忘 unlock（`NSLock+Extensions.swift`）。  
- P0/P1 历史竞态（HotKey 嵌套锁、ClipboardMonitor deinit 竞态）已在 v0.22.x 修复。

**剩余高风险**
- **SearchService 的 MainActor/queue 混用（P0）**  
  - 后台 queue 里读 recentItemsCache 无锁；  
  - invalidateCache 在主线程锁内写；  
  - 既破坏并发安全，又让“actor/lock”语义变得不可信。

### 2) ClipboardMonitor 任务队列

- `maxConcurrentTasks=3` 限流合理；大内容 hash 后台化。  
- 但 “processingQueue vs taskIDMap” 在丢弃最旧任务时未同步更新 map（`ClipboardMonitor.swift:279-314`）。  
  可能导致短时间 map 积压、后续重建队列时顺序漂移。  
  **不一定导致崩溃，但解释“快速复制大文件时偶现错乱/漏项”的可能性**。

### 3) 生命周期与任务泄漏

- AppState/SettingsView/HistoryItemView 都保存 Task 引用并在 cancel 时置 nil → 整体质量高。  
- RealClipboardService.stop() 先 stopMonitoring 再 cancel monitorTask，避免悬挂（正确）。

---

## 🔐 安全性审查

### 已覆盖的安全点
- **路径遍历防护**：`validateStorageRef` 要求 UUID 文件名、禁止 `..`、检查 symlink、验证在允许目录下（`StorageService.swift:1215-1256`）。  
- **外部文件加载最大 100MB 限制**（`StorageService.maxExternalFileSize`），避免内存耗尽。  
- **文件 URL 序列化使用 path 而非 absoluteString**，避免 file:// 前缀问题与解析错误（`ClipboardMonitor.serializeFileURLs`）。

### 仍可增强（低优先级）
- 对 NSPasteboard 输入的 “HTML/RTF/文件路径” 做更严格的大小/格式校验，防止恶意超大内容触发慢路径。  

---

## 🧪 测试与可维护性审查

### 测试现状
- 单测覆盖核心服务（Storage/Search/Monitor/HotKey/并发/性能），并带 Perf baseline。  
- ConcurrencyTests 关注取消与 cache 刷新，但**未覆盖 SearchService invalidateCache 并发写场景**（建议补一条）。  
- UI 测试仍缺失（README 也标注待办）。

### 可维护性
- 版本文档详尽，性能修复有指标。  
- 但 SearchService 当前结构（MainActor + queue）是维护风险点：后续任何“看似局部”的改动都会放大竞态。

---

## 📋 后续行动清单（按优先级）

### P0（必须尽快）
1. **修 SearchService 缓存并发**  
   - 方案 A（推荐）：移除 `@MainActor`，让 SearchService 完全后台化；所有缓存/SQL 访问都在同一 `queue` 内。  
   - 方案 B：保留 MainActor，去掉 queue，所有 search 在 Task.detached + MainActor.run 更新 UI。  
   - 必须保证 recentItemsCache 读写同一隔离域。

2. **补单测覆盖并发 invalidateCache**  
   - 构造 search 与 invalidateCache 同时发生的 race，验证无崩溃/无错结果。

### P1（结构性优化）
3. **后台化外部写盘与缩略图生成**  
   - storeExternally / generateThumbnail / cleanup SQL 均应在后台执行；  
   - MainActor 只负责把结果推到 UI。

4. **Fuzzy 系列“全量正确性 vs 性能”重新对齐**  
   - 选择“全量 fuzzy + FTS 候选”或“仅 recent fuzzy + UI 明示范围”。

### P2（质量提升）
5. **ClipboardMonitor 队列一致化**  
   - drop oldest 时同步移除 taskIDMap；或干脆只保留 map。  

6. **清理死代码/统一缓存**  
   - 移除 `IconCache.getCached` 或实现它；  
   - 可选把 AppFilterButton 缓存复用 IconCacheSync。

---

## 🧾 v0.24 变更记录

### 修复
- **Hover 预览闪烁**（`HistoryListView.swift`）：增加退出防抖与 popover hover 保活机制。

### 测试
- `make test-unit`：51 tests / 1 perf skipped / 0 failures。

---

**维护者**: Codex CLI (GPT‑5.2)  
**最后更新**: 2025-12-12
